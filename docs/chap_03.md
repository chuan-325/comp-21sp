# C3 词法分析

<!-- ! TODO -->

> 提示: 本页面未施工完成, 请谨慎辨别.

## 3.1 词法分析的作用

词法分析器的主要任务: **识别词素**

- 读入源程序的输入字符, 将它们组成词素, 然后生成并输出一个 **词法单元序列**.

词法分析器和符号表的交互 (由语法分析器调用词法分析器来实现):

1. 发现词素: 添加到符号表
2. 决定向语法分析器传送哪个词法单元: 从符号表中读取有关标识符种类的信息

![lex-symbol-parser](chap_03.assets/lex-symbol-parser.png)

词法分析器在编译器中负责读取源程序,
因此它除了识别词素之外,
还需要:

- 过滤源程序中的空白符(空格/ 制表符/ 换行符),
- 将编译器生成的错误消息与源程序的位置联系起来.

因此有时也将词法分析器分成两个级联的处理阶段:

1. **扫描阶段**: 完成不需要生成词法单元的简单处理;
2. **词法分析阶段**: 处理扫描阶段的输出, 生成词法单元.

### 3.1.1 词法分析 vs 语法分析

将词法分析和语法分析分离开来, 可以:

1. 简化编译器设计 (因为至少简化了一项任务)
2. 提高编译器的效率
3. 增加编译器的可移植性 (将输入字符集/平台规则限制在词法分析中).

### 3.1.2 词法单元/模式/词素

- **词法单元/记号** (token): 词法单元名+可选属性值.
  - 词法单元名: 表示某种词法单位的抽象符号, 它们是语法分析器处理的符号.
- **模式**:一个词法单元的词素可能具有的形式.
- **词素** (lexeme): 源程序中的字符序列, 与某个词法单元的模式匹配, 并被词法分析器识别为该词法单元的一个实例

举例:

| 词素          | 词法单元   | 模式 (非正式!)                             |
| ------------- | ---------- | ------------------------------------------ |
| `if`          | if         | 'i', 'f'                                   |
| `!=`          | comparison | `<` or `>` or `==` or `>=` or `<=` or `!=` |
| score         | id         | 字母开头的字母/数字串                      |
| "core dumped" | literal    | 在 `""` 之间除 `"` 之外的字符              |

> 词法单元/记号/token 是源语言语法的终结符,
> 一般定义为枚举型:
>
> - 关键字 (if, else 这样的字符序列)
> - 算符(comparison, arithmetic op, ...)
> - 标识符(id)
> - 常数(number)
> - 字符串(literal)
> - 标点符号...

较为通用的词法单元:

| 词法单元          | 模式                   |
| ----------------- | ---------------------- |
| 关键字            | 关键字本身             |
| 运算符            | 单个/一类运算符        |
| 标识符(id)        | (和所有标识符模式匹配) |
| 常量(数字/字符串) | (数字/字面值字符串)    |
| 标点符号          | (应该也是本身吧...)    |

### 3.1.3 词法单元的属性

词法单元/记号的属性: 词法单元的特性/特征, 值是该特性/特征的值.

如果一个模式能匹配不止一个单词,
词法分析器必须为记号提供附加的信息 (属性, 比如到底匹配到了哪一个词素),
但有些记号不需要附加的属性值.

举例: 0 和 1 都能和词法单元 number 的模式匹配,
但是要生成可执行代码显然还需要知道到底找到了哪个词素

**词法单元名字(记号)将影响语法分析的决策, 而属性影响记号的翻译.**

词法单元名字和相关属性值常常可以写成**名字-属性对序列**,
如 `a=b+1;` 语句对应的词法单元序列:

```
<id, 指向符号表中 a 的条目的指针>
<assign_op>
<id, 指向符号表中 b 的条目的指针>
<add_op>
<number, 整数值 1>
```

说明:

- 通常, 一个记号具有一个属性值;
- 对于某些 `<词法单元名字, 属性值>` 对, 尤其是 **运算符/标点符号/关键字** 的对, 不需要有属性值.

### 3.1.4 词法错误

词法分析基本无法检出错误.

> 然而, 假设出现所有词法单元的模式都无法和剩余输入的某个前缀相匹配,
> 此时词法分析器就不能继续处理输入.

错误恢复策略:

- 最简单: **恐慌模式**. 从剩余的输入中不断删除字符, 直到词法分析器能在剩余输入前缀中发现一个正确的词法单元;
- 其他可以采取的策略 (试图修复): 删除一个多余的字符/插入一个遗漏的字符/用一个正确的字符代替一个不正确的字符/交换两个相邻的字符/...

## 3.2 输入缓冲

为什么要采用**缓冲区**?
词法分析程序可能要向前看若干个字符,
才能决定词素符号的确切性质.

缓冲区的选择:

- 只用一个单独的缓冲区: 无论缓冲区多大, 都不能保证词素符号不会被缓冲区的边界截断 (永远存在 N+1);
- 引入 **缓冲区对**: 将一个缓冲区分为相同的两个部分, 容量均为 N.

**缓冲区对** 的工作方案:

1. 每一次读入: 读入 N 个字符, 读入不足 N 个字符则在末尾用 eof 标志表明;
2. 输入缓冲区维护两个指针: 开始指针 (lexemeBegin) 和向前指针 (forward);
   - lexemeBegin: 标识当前词素的开头
   - forward: 向前扫描, 直到发现一个模式匹配
3. (加入**哨兵标记**) 在缓冲区末尾加入一个哨兵标记 eof, 使缓冲区末尾判定和输入末尾判定可以统一处理.

**缓冲区对** 的工作步骤:

1. 开始: 两个指针都指向下一个词素符号的第一个字符;
2. forward 向前扫描, 直至确定词素符号
   - 确定词素 (此时 forward 在这个词素的最右端)
   - 将词素 (从 lexemeBegin 到 foward) 返回语法分析器
   - 处理完成
3. lexemeBegin 指向刚找到的词素之后的第一个符号, forward 回退一个字符

<!-- 中文书本88/649 英文书本141/1035 -->

<!-- ## 记号的描述, 正则式

## 记号的识别

## 有穷状态自动机

## 正则式与有穷状态自动机的等价

## 词法分析程序的自动生成工具 -->

## 参考资料

1. [Input buffering in lexical analysis | SSCD | 17CS63 | 15CS63 | VTU - YouTube](https://www.youtube.com/watch?v=Vi2VKYMIvAI): 咖喱味略浓, 3:35 起讲解 buffer pair 工作机制;
2. [EasyExamNotes: Input buffering](https://www.easyexamnotes.com/p/input-buffering.html): 推荐阅读, 比较详细地描述了 buffer pair 的工作机制和两个指针的职责;
3. [Input Buffering in Compiler Design - GeeksforGeeks](https://www.geeksforgeeks.org/?p=289137): 虽然它讲得有点粗糙, 但是对比了 single buffer 和 double buffer, 所以也值得一看;
4. [What is input buffering? Explain technique of buffer pair. ~ FindAnyQuestion](https://www.findanyquestion.com/2020/05/what-is-input-buffering-explain-technique-of-buffer-pair.html): 带有比较详细的伪码;
5. [C# 词法分析器（二）输入缓冲和代码定位 - CYJB - 博客园](https://www.cnblogs.com/cyjb/p/LexerInputBuffer.html): 讲出了很重要的一点, buffer pair 相对于 single buffer 的优势在工程上更明显 (reduce overhead)), 而非理论科学领域的优势;
6. [Buffering | principles of compiler design](http://compilerdesigndetails.blogspot.com/2012/02/buffering.html): 唯一一份仔细讲了坏处的文章;

<!-- ! Scanners use double-buffering to minimize the overheads associated with this. -->
