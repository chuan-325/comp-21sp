# C8 代码生成和优化

> 提示: 本页面未施工完成, 请谨慎辨别.

<!-- 2021年6月10日 -->

> 关于 **代码生成器**:
>
> 代码生成器的作用
>
> - 接收前端生成的中间表示, 产生语义等价的目标代码
> - 符号表信息是重要的
>
> 代码生成器的输出必须是正确和高质量的
>
> 代码生成器的本身应该是高效的
>
> 产生最优化代码的问题是不可判定的

## 8.1 代码生成器设计中的问题

**代码生成器** 依赖于目标机器和操作系统, 最好能充分利用目标机器的资源, 以充分发挥目标机器的能力.

固有的问题:

- 存储管理
- 指令选择
- 寄存器分配
- 计算次序选择

可移植的代码生成器: 接收机器描述作为参数.

### 代码生成器的输入

**符号表信息**: 决定中间表示中名字所代表的数据对象的运行地址

所含信息: 偏移量, 作用域.

符号表信息, 可能在动态时刻作为调试信息存在

**中间表示**:

- 代码生成前, 中间表示记录了足够详细的程序信息
- 名字的值可以表示为目标机器能够直接操作的数
- 类型检查已经完成
- 明显的语义错误已经发现

### 目标程序

目标机器的微体系结构对代码生成有着巨大的影响.

RISC, CISC, VLIW, ("基于堆栈" 的目标机器,) 它们各自的寄存器特点/指令特点/寻址特点都需要编译器提供不同程度的支持.

目标程序的主要形式:

- 绝对机器语言
  - 可以放在内存中固定地方, 并立即执行
  - 小程序/需要迅速编译和执行的程序
- 可重定位的机器语言
  - 程序可以分为多个目标模块, 分别编译
  - 需要连接装配器将一组可重定位模块一起装入执行
  - 需要额外的开销, 但灵活: 可分别编译子程序和从目标模块中调用其它先前编译好的程序模块
  - 如果目标机器不能自动处理重定位, 则编译器必须提供显式的重定位信息给装配程序
- 汇编语言
  - 代码生成的过程容易: 可以产生符号指令和利用汇编器的宏
  - 避免了重复汇编器的工作
- 字节码

### 指令选择

指令选择的影响因素:

- IR 的层次
- 指令集体系结构本身的特性
- 想要达到的生成代码的质量

#### IR 的层次的影响

- 高层次的 IR: 代码生成器可以采用代码模板为每个 IR 语句生成对应的机器指令序列
  - 仅割裂地考虑每个语句自身的翻译, 目标代码质量堪忧
  - 需要后续的代码优化
- IR 中包含某些低层次细节, 代码生成器可以应用这些信息生成更好的代码

#### 指令集体系结构本身的特性

指令系统的**一致性**和**完整性**:
如果目标机器不能以一致的方式支持各种数据类型, 则每种例外都要专门的处理

**指令的速度**和**机器的特点**:
如果不考虑目标程序的效率, 则指令选择是直截了当的, 但是逐条语句地产生代码的方法常常产生低质量的代码.

#### 想要达到的生成代码的质量

代码的质量取决于它的执行速度和长度.

- 要设计良好的代码序列, 必须知道指令的代价(时间/功耗等), 但该信息是难以获得的
- 对于一个给定的三地址构造, 可能要根据其**上下文**才能最终确定其对应的最好的机器代码序列

### 代码生成策略

#### 寄存器分配

> 寄存器的特点: 快
>
> 利用寄存器放置运算对象的指令比运算对象在内存中的指令短些, 执行也快些

实际上寄存器使用问题包括寄存器分配和指派:

- 寄存器分配: 对源程序的每个点, 选择驻留在寄存器中的一组变量
- 寄存器指派: 挑出变量将要驻留的具体寄存器

> 寄存器分配的最优化是 NPC 问题.

corner case? 满足特定要求:

- 运算分量和结果使用寄存器对 (一个偶数号寄存器和相邻的奇数号寄存器)
  - 举例: 乘除法指令, SRDA 指令

#### 求值顺序

计算执行的次序会影响目标代码的效率

> 选择最佳次序是一个 NP 完全问题

## 8.2 目标语言

> 熟悉目标机器和它的指令系统是设计一个好的代码生成器的先决条件, 但不存在通用的有效的机器描述.
>
> 本节介绍一个简单计算机的汇编语言作为目标语言, 可以概要代表很多寄存器机器.
>
> 本章的很多代码生成技术也可以用于其它类型的机器

### 一个简单的目标机模型

基本信息:

- 三地址机器:
  - 具有加载和保存操作/计算操作/跳转操作和条件跳转
- 字节寻址
- 寄存器:
  - 有 n 个通用寄存器 R0 , R1 , ... , Rn-1
- 指令集:
  - 有限的指令集, 且假设所有运算分量都是整数
- 指令形式:
  - 大部分指令包括一个运算符/一个目标地址, 最后是一个源运算分量列表, 指令前可能有一个标号, be like `(label: ) op dst src`
    - 加载: `LD dst, addr`
    - 保存: `ST x, r`
    - 计算: OP dst, src1( ,src2)
    - 无条件跳转: BR L
    - 条件跳转: Bcond r, L

<!-- TODO: p19-20, 寻址 -->

### 程序和指令的代价 (评估约定)

> 目标程序的 "代价" 是编译器考虑的一个重要指标.
>
> 根据编译器目标的不同, 而采用不同的度量. 常用的一些度量有: 编译时间/代码大小/运行时间或能耗等的某个或某几个的组合.
>
> 确定编译和运行一个程序的实际代价是一个复杂的问题.

本章对**程序代价度量的选择**:

- 把指令代价置为 1, 加上上述的地址模式的附加代价, 就是对应指令的长度 (以字计算)
- 寄存器地址模式的代价为 0
- 含内存单元和常数的地址模式的代价是 1, 因为这种运算对象必须和指令存在一起

本章中, **程序代价的计算**:

- 对于一个指定的输入, **目标语言程序的代价**是: 当此程序在该输入上运行时, 所执行的所有指令的**代价总和**

如果空间是至关重要的, 则应使指令的长度极小化. 此种优化有如下的两个额外好处:

- 节省取指的开销, 从而减少指令的执行时间
- 提高指令 cache 的使用效率

## 8.3 目标代码中的地址

### 静态分配管理

<!-- TODO: p28-30 -->

### 栈式分配管理

<!-- TODO: p31-35 -->

### 名字的运行时刻地址

<!-- TODO: p36 -->

## 8.4 基本块及其优化

<!--
## 8.5 控制流图及流分析
## 8.6 跨越基本块的优化
## 8.7 一个简单的代码生成器
## 8.8 窥孔优化
## 8.9 寄存器分配和指派
## 8.10 通过树重写来选择指令
## 8.11 指令调度
-->
