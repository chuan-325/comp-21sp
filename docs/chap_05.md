# Chap 05 语法制导的翻译

> 提示: 本页面未施工完成, 请谨慎辨别.

>  鸣谢: [@CacaoGatto](https://github.com/CacaoGatto)

## 基础知识

<!-- 属性, 属性联编 -->

**语义规则与产生式相联系**的两种表示方式:

- 语法制导定义: 属性直接与语言的文法符号相联系
  - 抽象, 无需指明计算次序, 易于理解
- 翻译方案: 将语义动作嵌入产生式右部合适的位置
  - 指明语义规则计算次序, 实现更高效

## 5.1 语法制导定义/SDD

语法制导定义/SDD: 上下文无关文法和属性及规则的结合.

- 关联: 属性~文法符号,规则~产生式

对于分析树结点 N 上的非终结符号 A , 讨论两种属性:

- A 的 **综合属性** (synthesized):
  - 由 N 上的产生式所关联的语义规则定义
  - 只能通过 N 的子结点/N 本身的属性值定义 (下至上)
  - A 必然为产生式头
- A 的 **继承属性** (inherited)
  - 由 N 的父结点上的产生式所关联的语义规则定义
  - 只能通过 N 的父结点/N 本身/N 的兄弟结点上的属性值来定义
  - A 必然出现在产生式体中

终结符号**可以具有综合属性**, 但不能具有继承属性.

> 每个文法符号的继承属性集和综合属性集的交集为空.

- 终结符号的 (**综合**) 属性值: **词法分析器**提供的**词法值**. SDD 中没有计算终结符号属性值的语义规则.

> 语义规则通过计算次序决定了属性的依赖关系.

S 属性的 SDD: 只包括综合属性的 SDD.

- 每个规则都根据相应产生式的**产生式体中的属性值**来计算**产生式头部非终结符号**的一个属性.

属性文法: 语义规则函数无副作用的语法定义.

- 仅通过其他属性值和常量值来定义属性值
- 以表格表示, 下标区分同名文法符号, 一个产生式可能对应 0 或多个语义规则

继承属性: 解决 "语法分析树结构和源代码抽象语法" 不匹配的情况

> 考虑 `3*5` 的注释语法分析树, 结点 '\*5' 一定会继承其左结点的值, 根节点的值由 '\*5' 结点的综合属性定义.
>
> ```
> T.val = 15
> |        \
> F.val=3   T'.inh=3,
>           T'.syn=15
>           /  |       \
>          *   F.val=5  T1'.inh = 15
>              |        T1'.syn = 15
>              ...       ...
> ```

**注释语法分析树**: 标注属性值

- 自底向上可以注释综合属性
- 同时具有继承属性和综合属性的 SDD 可能需要多次遍历

## 5.2 SDD 的求值顺序

Basics:

- 对于一棵语法分析树的结点 (标号为文法符号 X), 和 X 关联的每个属性都有对应的依赖图结点
- **综合**: 若产生式 p 关联的语义规则通过 X.c 定义了综合属性 A.b, 则依赖图中存在一条从 X.c 到 A.b 的边.
- **继承**: 若产生式 p 关联的语义规则通过 X.a 定义了继承属性 B.c, 则依赖图中存在一条从 X.a 到 B.c 的边. (X 是 B 的父亲/自身/兄弟)

依赖图的表示:

- A to B 实线: 依赖图中, A 定义了 B
- A to B 虚线: 语法分析树的边
- 结点上标出拓扑序号

依赖图的拓扑排序刻画了求值顺序.

如果依赖图有环, 则不存在拓扑排序. 如果没有环, 则至少存在一个拓扑排序.

S 属性的 SDD:

- 定义: 每个属性都是综合属性
- 特性: 可以在自底向上的语法分析过程中实现 (后序遍历, 恰好对应将产生式体规约为产生式头的过程); 综合属性求值过程不会显式创建语法分析树的结点.

L 属性的 SDD:

- 思想: 产生关联的属性之间, **边总是从左到右**
- 定义: 每个属性要么是综合属性, 要么是由其父亲/左兄弟结点/自身属性定义的继承属性, 且不存在成环
  - 父结点关联的继承属性
  - 左侧文法符号实例相关的继承/综合属性
  - 来自同一实例的无环属性

副作用: 如计算器打印结果, 代码将标识符放入符号表

SDD 在属性文法 vs 翻译方案中找平衡点: 允许部分副作用+限定求值顺序

- 属性文法没有副作用, 支持任何与依赖图一致的求值顺序
- 翻译方案要求左到右求职, 允许语义动作中包含任何程序片段

副作用支持:

1. 支持不会对属性求值产生约束的附带副作用
2. 对允许的求值顺序添加约束,使得以任何允许的顺序求值都会得到相同的翻译结果 (即隐含加入到依赖图中的边)

> 书本 p201 底下有个例子 `L->En`可以说明这种 "顺序约束".

## 5.3 语法制导翻译的应用

对同样的加减法文法, 对比 p204-205 的两个例子:

- 普通的自底向上: S 属性 SDD.
- 自顶向下: 抽象语法树和语法分析树结构差异较大. L 属性 SDD.

后者有继承属性, 这和它自顶向下的选择有关.

考虑类型检查 `int [2][3]` , 语言设计导致语法分析树结构和抽象语法树结构不同. 借助继承属性传递 integer 类型信息.

总结:

- 语法树不同于分析树, 后者只是一个抽象的概念, 后者是实际的构造
- 每个结点都有一个标号字段 op
- 结点创建时需要有相应个数附加字段
- S 属性构建中, 非终结符都有一个综合属性结点
- L 属性构建中, 子表达式元素出现在不同子树时需要引入继承属性
- 语法分析树和抽象语法树的差异也会引入继承属性, 如类型表达式


## 5.4 语法制导的翻译方案/SDT

<!-- https://github.com/CacaoGatto/ucas-compiler-20sp-notes/blob/main/chapter5.md -->