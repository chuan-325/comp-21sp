# hw 05 - 02

## Ex. 1

下面是涉及运算符+和整数 (integer) 或浮点 (float) 运算分量的表达式的文法. 区分浮点数的方法是看它有无小数点.

```
E -> E + T | T
T -> num . num | num
```

(1) 给出一个 SDD 来确定每个项 T 和表达式 E 的类型, 要求整数与浮点数运算得到浮点数;

(2) 扩展 (1) 中得到的 SDD, 使得它可以把表达式转换为前缀表达式.

> 使用一个单目运算符 intToFloat 把一个整数转换为相等的浮点数, 使用 `||` 拼接操作符和操作数.

### Solution

(1) SDD:

| 产生式           | 语义规则                                                                      |
| ---------------- | ----------------------------------------------------------------------------- |
| `E -> E1 + T`    | `if E1.type == T.type` <br> `then E.type = E1.type`<br> `else E.type = float` |
| `E -> T`         | `E.type = T.type`                                                             |
| `T -> num . num` | `T.type = float`                                                              |
| `T -> num`       | `T.type = integer`                                                            |

(2) 语义规则更新如下:

> 按老师答案修改一部分:

```pseudocode
# 产生式 1: E -> E1 + T
if E1.type == T.type
    E.type=E1.type
else
    begin
        E.type = float
        if (E1.type==integer)
            E1.type = float
            E1.val = "intToFloat" || E1.val
        else
            T.type = float
            T.val = "intToFloat" || T.val
    end
E.val  = E.type '+' || E1. val || T.val

# 产生式 2: E -> T
E.type = T.type
E.val = T.val

# 产生式 3: T -> num . num
T.type = float
T.val = num . num

# 产生式 4: T -> num
T.type = integer
T.val = num
```

> 原答案:

```pseudocode
# 产生式 1: E -> E1 + T
if E1.type == T.type
    E.type=E1.type
else
    begin
        E.type = float
        if (E1.type==integer)
            E1=intToFloat(E1)
        else
            T=intToFloat(T)
    end
E.val  = {print '+'} E1. val + T.val

# 产生式 2: E -> T
E.type = T.type
E.val = T.val

# 产生式 3: T -> num . num
T.type = float
T.val = num . num

# 产生式 4: T -> num
T.type = integer
T.val = num
```

## Ex. 2

改写下面的 SDT:

```
A -> A { a } B | A B { b } | 0
B -> B { c } A | B A { d } | 1
```

使得基础文法变成非左递归的. 其中 a, b, c 和 d 是语义动作, 不涉及属性计算, 0 和 1 是终结符号.

### Solution

由于语义动作不涉及属性计算, 直接改写:

```
A -> 0 H
H -> { a } B H | B { b } H | ε
B -> 1 G
G -> { c } A G | A { d } G | ε
```

## Ex. 3

![ex03](hw_05_02.assets/ex03.png)

(1)修改图 5-25 中的 SDD, 使它包含一个综合属性 B.le, 即一个 Box 的长度. 两个 Box 并列及下标后得到的 Box 的长度是这两个 Box 的长度和.

(2) 然后, 将你的新规则加入到图 5-26.

### Solution

(1) 注释内为产生式, 紧接其后的是语义规则 (带\*为新增)

```pseudocode
# 产生式 1: S -> B
B.ps = 10

# 产生式 2: B -> B1 B2
B1.ps = B.ps
B2.ps = B.ps
B.ht = max(B1.ht, B2.ht)
B.dp = max(B1.dp, B2.dp)
*B.le = B1.le + B2.le

# 产生式 3: B -> B1 sub B2
B1.ps = B.ps
B2.ps = 0.7 * B.ps
B.ht = max(B1.ht, B2.ht-0.25*B.ps)
B.dp = max(B1.dp, B2.dp+0.25*B.ps)
*B.le = B1.le + B2.le

# 产生式 4: B -> (B1)
B1.ps = B.ps
B.ht = B1.ht
B.dp = B1.dp
*B.le = B1.le

# 产生式 5: B -> text
B.ht = getHt(B.ps, text.lexval)
B.dp = getDp(B.ps, text.lexval)
*B.le = getLe(B.ps, text.lexval)
```

(2) 将语义规则加入 SDT: (带\*为新增)

```
# Production   &  Action
(1) S ->         { B.ps = 10; }
		B
(2) B ->		{ B1.ps = B.ps; }
		B1 		{ B2.ps = B.ps; }
		B2 		{ B.ht = max(B1.ht, B2.ht);
				  B.dp = max(B1.dp, B2.dp);
				 *B.le = B1.le + B2.le;}
(3) B ->		{ B1.ps = B.ps; }
		B1 sub  { B2.ps = 0.7 * B.ps; }
		B2 		{ B.ht = max(B1.ht, B2.ht-0.25*B.ps);
				  B.dp = max(B1.dp, B2.dp+0.25*B.ps);
				 *B.le = B1.le + B2.le;}
(4) B -> (		{ B1.ps = B.ps;}
		B1)	    { B.ht = B1.ht;
				  B.dp = B1.dp;
				 *B.le = B1.le}
(5) B -> text	 {B.ht = getHt(B.ps, text.lexval);
				  B.dp = getDp(B.ps, text.lexval);
				 *B.le = getLe(B.ps, text.lexval);}
```
