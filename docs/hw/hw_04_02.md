# hw 04 - 02

## Ex. 1

(1) 使得文法的预测分析产生回溯的原因是什么?

(2) 仅使用 FIRST 集合可以避免回溯吗? 为什么?

### Solution

使预测分析器产生回溯的原因: 文法产生式中存在左因子, 因而预测分析器无法根据读入符号做出唯一的选择判断.

仅使用 FIRST 集合不一定能避免回溯, 因为仅仅使用 FIRST 集合无法在一个非终结符号可以被替换为 ε 时做出准确的选择. 考虑文法 `S -> 0S0|ε` , 输入 `0000` , 在匹配到第一个 `0` 的时候, 无法确定产生式的选择, 只有通过配合 FOLLOW 集 (`FOLLOW(S)={$, 0}`) 构造预测分析表才能做出唯一的准确的选择.

## Ex. 2

考虑文法:

```
   rexpr -> rexpr + rterm | rterm
   rterm -> rterm rfactor | rfactor
 rfactor -> rfactor * | rprimary
rprimary -> a | b
```

(1) 消除左递归;

(2) 求得该文法的 FIRST 集合和 FOLLOW 集合;

(3) 说明所得的文法是 LL(1) 文法;

(4) 为所得的文法构造 LL(1) 分析表;

(5) 对输入串 `a + a * + b *` 给出相应得 LL (1) 分析程序的动作.

### Solution

#### (1)

文法的前三条规则都含有左递归, 引入 $\text{A}, \text{B}, \text{C}$ 变量, 消除后左递归的文法如下:

```
   rexpr -> rterm A
       A -> + rterm A | ε
   rterm -> rfactor B
       B -> rfactor B | ε
 rfactor -> rprimary C
       C -> * C | ε
rprimary -> a | b
```

#### (2)

| 非终结符号 | FIRST 集合  | FOLLOW 集合       |
| ---------- | ----------- | ----------------- |
| `rprimary` | `{a, b}`    | `{+, $, a, b, *}` |
| `C`        | `{ε, *}`    | `{+, $, a, b}`    |
| `rfactor`  | `{a, b}`    | `{+, $, a, b}`    |
| `B`        | `{ε, a, b}` | `{+, $}`          |
| `rterm`    | `{a, b}`    | `{+, $}`          |
| `A`        | `{ε, +}`    | `{$}`             |
| `rexpr`    | `{a, b}`    | `{$}`             |

#### (3)

**i. 该文法的任意 A -> α | β 中, FIRST(α) 和 FIRST(β) 不相交.**

> (在一般情况下) 保证每一个 `A -> α | β` 都能根据一个向前看符号决定下一步.

讨论所有可能出现冲突的情况:

```
// A -> + rterm A | ε
FIRST(+ rterm A)={+}   , FIRST(ε)={ε}, 不相交

// B -> rfactor B | ε
FIRST(rfactor B)={a, b}, FIRST(ε)={ε}, 不相交

// C -> * C | ε
FIRST(* C)={*}         , FIRST(ε)={ε}, 不相交

// rprimary -> a | b
FIRST(a)={a}           , FIRST(b)={b}, 不相交
```

故该条成立.

**ii. 该文法的任意 A -> α | β 中, 若 ε 在 FIRST(β) 中则 FIRST(α) 和 FOLLOW(A) 不相交, 反之亦然.**

> 在 **FIRST 集合中存在 ε 的情形** 下,
> 保证每一个 `A -> α | β` 都能根据一个向前看符号决定下一步.

讨论所有可能出现冲突的情况:

```
// A -> + rterm A | ε
FIRST(+ rterm A)={+}, FOLLOW(+ rterm A)={$}, 不相交

// B -> rfactor B | ε
FIRST(rfactor B)={a, b}, FOLLOW(rfactor B)={+, $}, 不相交

// C -> * C | ε
FIRST(* C)={*}, FOLLOW(*C)={+, $, a, b}, 不相交
```

故该条成立.

综上所述, 该文法是 LL(1) 的.

#### (4)

| 非终结符 \ 输入 | a                     | b                     | +              | \*        | $      |
| --------------- | --------------------- | --------------------- | -------------- | --------- | ------ |
| rexpr           | rexpr -> rterm A      | rexpr -> rterm A      |                |           |        |
| A               |                       |                       | A -> + rterm A |           | A -> ε |
| rterm           | rterm -> rfactor B    | rterm -> rfactor B    |                |           |        |
| B               | B -> rfactor B        | B -> rfactor B        | B -> ε         |           | B -> ε |
| rfactor         | rfactor -> rprimary C | rfactor -> rprimary C |                |           |        |
| C               | C -> ε                | C -> ε                | C -> ε         | C -> \* C | C -> ε |
| rprimary        | rprimary -> a         | rprimary -> b         |                |           |        |

#### (5)

| 已匹配          |                 栈 |              输入 | 动作                         |
| --------------- | -----------------: | ----------------: | ---------------------------- |
|                 |          `rexpr $` | `a + a * + b * $` |                              |
|                 |        `rterm A $` | `a + a * + b * $` | 输出 `rexpr -> rterm A`      |
|                 |    `rfactor B A $` | `a + a * + b * $` | 输出 `rterm -> rfactor B`    |
|                 | `rprimary C B A $` | `a + a * + b * $` | 输出 `rfactor -> rprimary C` |
|                 |        `a C B A $` | `a + a * + b * $` | 输出 `rprimary -> a`         |
| `a`             |          `C B A $` |   `+ a * + b * $` | 匹配 `a`                     |
| `a`             |            `B A $` |   `+ a * + b * $` | 输出 `C -> ε`                |
| `a`             |              `A $` |   `+ a * + b * $` | 输出 `B -> ε`                |
| `a`             |      `+ rterm A $` |   `+ a * + b * $` | 输出 `A -> + rterm A`        |
| `a +`           |        `rterm A $` |     `a * + b * $` | 匹配 `+`                     |
| `a +`           |    `rfactor B A $` |     `a * + b * $` | 输出 `rterm -> rfactor B`    |
| `a +`           | `rprimary C B A $` |     `a * + b * $` | 输出 `rfactor -> rprimary C` |
| `a +`           |        `a C B A $` |     `a * + b * $` | 输出 `rprimary -> a`         |
| `a + a`         |          `C B A $` |       `* + b * $` | 匹配 `a`                     |
| `a + a`         |       ` * C B A $` |       `* + b * $` | 输出 `C -> * C`              |
| `a + a *`       |          `C B A $` |         `+ b * $` | 匹配 `*`                     |
| `a + a *`       |            `B A $` |         `+ b * $` | 输出 `C -> ε`                |
| `a + a *`       |              `A $` |         `+ b * $` | 输出 `B -> ε`                |
| `a + a *`       |      `+ rterm A $` |         `+ b * $` | 输出 `A -> + rterm A`        |
| `a + a * +`     |        `rterm A $` |           `b * $` | 匹配 `+`                     |
| `a + a * +`     |    `rfactor B A $` |           `b * $` | 输出 `rterm -> rfactor B`    |
| `a + a * +`     | `rprimary C B A $` |           `b * $` | 输出 `rfactor -> rprimary C` |
| `a + a * +`     |        `b C B A $` |           `b * $` | 输出 `rprimary -> b`         |
| `a + a * + b`   |          `C B A $` |             `* $` | 匹配 `b`                     |
| `a + a * + b`   |        `* C B A $` |             `* $` | 输出 `C -> * C`              |
| `a + a * + b *` |          `C B A $` |               `$` | 匹配 `*`                     |
| `a + a * + b *` |            `B A $` |               `$` | 输出 `C -> ε`                |
| `a + a * + b *` |              `A $` |               `$` | 输出 `B -> ε`                |
| `a + a * + b *` |                `$` |               `$` | 输出 `A -> ε`                |
