# C4 语法分析

> 提示: 本页面未施工完成, 请谨慎辨别.

## 4.1 引论

### 4.1.1 语法分析器的作用

### 4.1.3 语法错误的处理

### 4.1.4 错误恢复策略

#### 恐慌模式的恢复

#### 短语层次的恢复

#### 错误产生式 (出错产生式)

1. 根据经常出现的错误, 构造产生错误结构的产生式 (需要对错误的相对了解);
2. 产生式的被匹配意味着错误的出现, 从而可以据此给出适当的错误信息

#### 全局纠正

## 4.2 上下文无关文法的分析及改造

自下而上的处理能力一般高于自上而下;
但两者一般而言都不能保证二义性文法的处理 (不是一定不能, 是不一定能);
对编译大致够用?
对自然语言不一定够用.

## 4.3 设计文法

## 4.4 自顶向下的分析

### 4.4.1 递归下降 (Recursive Down) 的语法分析

不写出回溯的算法伪代码:

```c
void A(){
    Choose an A-production(A=>X_1X_2...X_k);
    for (i=1; i<=k; i++) {
        if (X_i is nonoterminal) call procedure X_i();
        else if (X_i == current input symbol) advance the input to next symbol;
        else /*error - or go backward*/;
    }
}
```

一般的自顶向下分析存在的问题:

1. 若文法存在左递归 ($A\overset{+}\Rightarrow A\alpha$), 则将无限循环;
2. 当非终结符用某个选择匹配成功时, 可能后面还是不匹配, 是虚假的成功, 故需要回溯技术
3. 回溯=有重复工作, 建议消除回溯;
4. 最终报告 "分析不成功" 时, 难以定位出错的确切位置;
5. 带回溯的自顶向下分析是一种穷举搜索, 代价极高.

### 4.4.2 FIRST/FOLLOW 集: 确定的递归下降分析

- Q: 如何消除回溯?
- A: 匹配输入串时, 算法能根据面临的输入符号准确地指派一个产生式选择, 且工作结果是确信无疑的.
- Q': 什么叫 "准确地指派"?
- A': 见下.

##### FIRST/FOLLOW 集的定义

引入 FIRST 集和 FOLLOW 集.

**FIRST 集**: 文法 $G$ 是不含左递归的文法,
对于 $G$ 的**任意文法符号串** $\alpha$ ,
FIRST 集是它的开始符号集合 (**终结首符集合**):

$$
FIRST(\alpha):=\{a|\alpha\overset{*}\Rightarrow a\dots, a\in V_T\}
$$

> 如果 $\alpha$ 可以推导出 $\epsilon$, 则 $\epsilon\in FIRST(\alpha)$.

回答 "准确地指派":
如果非终结符 $A$ 的任意两个选择的开始符号集满足 $FIRST(a_i)\cap FIRST(a_j)=\emptyset$,
且空串不是关于 $A$ 的所有开始符号集的元素,
则 $A$ 就可以根据所面临的第一个输入符号,
准确地指派一个选择去执行任务.

**FOLLOW 集**: 对于文法 $G$ 的任意非终结符 $A$ , FOLLOW 集是它的**后继符号集合** (紧接在 $A$ 之后的终结符号/$\$$符号):

$$
FOLLOW(A)=\{a|S\overset{+}\Rightarrow\dots Aa\dots, a\in V_T\}
$$

> 如果 $A$ 可以是某个句型的最右符号,
> 则表示输入结束的符号 $\$\in FOLLOW(A)$.

对于语法树中的某个非终结符号结点,
FIRST 集中的终结符号会出现在结点子树的最左叶子结点,
FOLLOW 集中的终结符号会出现在结点右侧的最左叶子结点.

##### FIRST/FOLLOW 集的计算

<!-- ! -->

计算 $FIRST(X)$:
(应用以下规则, 直至没有新的终结符号 or $\epsilon$ 可加入)

1. 如果 $X$ 是一个终结符号,
   则 $FIRST(X)=X$;
2. 如果 $X$ 是一个非终结符号,
   - 若有产生式 $X\rightarrow Y_1Y_2\cdots Y_k$, $k\geq1$,
     则对所有满足 $Y_1\cdots Y_{i-1}\overset{*}\Rightarrow\epsilon$ 的 $i$,
     将 $FIRST(Y_i)$ 中的所有非 $\epsilon$ 符号加入 $FIRST(X)$;
   - 若对于所有的 $j=1,2,\cdots, k$, 都有 $\epsilon\in FISRT(Y_j)$, 则将 $\epsilon$ 加入 $FIRST(X)$;
3. 如果 $X\rightarrow\epsilon$ 是一个产生式, 则将 $\epsilon$ 加入 $FIRST(X)$.

计算所有非终结符号的 $FOLLOW$ 集:
(应用以下规则, 直至没有新的终结符号 or $\epsilon$ 可加入)

1. 将 $\$$ 放入 $FOLLOW(S)$ 中,
   其中 $S$ 是开始符号, $\$$ 是输入右端的结束标记;
2. 如果存在产生式 $A\rightarrow \alpha B\beta$,
   则将 $FIRST(\beta)$ 中**所有的非 $\epsilon$ 符号**加入 $FOLLOW(B)$;
3. 如果存在一个产生式 $A\rightarrow\alpha B$
   或 存在产生式 $A\rightarrow \alpha B \beta$ 且 $\epsilon\in FIRST(\beta)$,
   则将 $FOLLOW(A)$ 中的**所有符号**加入 $FOLLOW(B)$.

<!--! 预测分析器 -->

### 4.4.3 LL(1) 文法

**LL(1) 文法**:
一个文法如果是 LL(1) 的,
当且仅当 $G$ 的任何两个产生式
$A\rightarrow\alpha|\beta$
满足:

1. $FIRST(\alpha)\cap FIRST(\beta)=\emptyset$,
2. 若 $\beta\overset{*}\Rightarrow\epsilon$,
   则 $FIRST(\alpha)\cap FOLLOW(A)=\emptyset$,
   反之同.

LL(1) 文法可描述大部分程序设计语言构造,
无需回溯.

<!-- 算法 4.33 构造预测分析表 -->

- 输入: 文法 `G`
- 输出: 预测分析表 `M`

**方法**:
对于文法 `G` 的每一个产生式 `A->α` , 作如下处理:

1. 对于 `FIRST(α)` 中的每个终结符号 `a` ,
   将 `A->α` 加入到 `M[A,a]` 中;
2. 如果 `ε` 在 `FIRST(α)` 中,
   那么对于 `FOLLOW(A)` 中的每个终结符号 `b` (也可以是 `$`),
   将 `A->α` 加入到 `M[A,b]` (相应可能是 `M[A,$]`) 中.

完成如上操作后,
仍然空白的表项即为 "error" 表项.

<!-- !是否LL(1)<=>分析表的条目有无重复-->

如何判断一个文法是 LL(1) 的?

一个文法 `G` 是 LL(1) 的,
当且仅当 `G` 的任意两个不同的产生式
`A -> α | β`
满足以下条件:

1. $FIRST(\alpha)\cap FIRST(\beta)=\emptyset$;
2. $\epsilon\in FIRST(\beta)\Rightarrow FIRST(\alpha)\cap FOLLOW(A)=\emptyset$, 反之亦然.

### 4.4.4 非递归的预测分析

<!-- 末尾 -->

已匹配+输入=all

### 4.4.5 预测分析中的错误恢复

<!-- ppt64 -->

**发现错误**:

考虑一个由分析表驱动的预测分析器的栈, 当以下两种情况之一发生时预测语法分析过程就可以检测到语法错误:

1. 栈顶的终结符号和下一个输入符号不匹配;
2. 非终结符号 $A$ 处于栈顶, $a$ 是下一个输入符号, 且 $M[A, a]$ 为 error (即相应的语法分析表条目为空).

> 对于由分析表驱动的预测分析器, 它的栈明确地显示了语法分析器期望用哪些终结符号/非终结符号来匹配余下的输入; 同样的方法也可以用于递归下降分析器 (它的栈是隐式的).

#### 恐慌模式

紧急错误恢复策略.

跳过一些输入符号, 直到出现一个期望的同步记号
(有效性依赖于同步记号集合的选择).

(示例) 启发式规则: 同步记号的选择

<!-- !只是简略版 -->

| No. | Rule                                                                             | Example (action/rule)                                          |
| --- | -------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| 1   | 将 $FOLLOW(A)$ 中的所有符号放入非终结符 $A$ 的同步记号集合                       | 跳过一些记号, 直到看到 $FOLLOW(A)$ 中的元素时, 再把 $A$ 弹出栈 |
| 2   | 将较高层构造的开始符号加入到较低层构造的同步集合中;                              | 把语句开头的关键字加人到生成表达式的非终结符号的同步集合中去   |
| 3   | 把 $FIRST(A)$ 的符号加入 $A$ 的同步集合                                          |                                                                |
| 4   | 如果非终结符可以产生空串, 若出错时栈顶是这样的非终结符, 则可使用产生空串的产生式 |                                                                |
| 5   | 如果终结符在栈顶而不能匹配, 简单的方法是弹出此终结符                             |                                                                |

<!-- !... -->

#### 短语层次的恢复

**实现方法**: 在预测语法分析表的空白条目中填写指向处理例程的指针.
这些例程可以改变/插入/删除输人中的符号, 并发出适当的错误消息.
它们也可能执行一些出栈操作.

<!-- !会出现的问题, 原因 (ppt70)-->

## 4.5 自底向上的分析

bottom-up 语法分析的通用框架: 移入-归约语法分析.

### 4.5.1 归约

bottom-up 的语法分析过程可以看成将一个串 $w$ "归约" 为文法开始符号的过程.

在单个
**归约**
(reduction)
步骤中,
一个与某产生式体相匹配的特定子串被替换为该产生式头部的非终结符号.

因此, 核心问题是: 选择文法符号串的哪一个子串进行归约?

根据定义,
一次归约是一个推导步骤的反向操作,
因此,
自底向上语法分析的目标是反向构造一个推导过程.

#### 4.5.2 句柄剪枝

**句柄** (handle):

- (非正式定义):
  和某个产生式体匹配的子串,
  对它的归约代表了相应的最右推导中的一个反向步骤;
- (**正式定义**):
  如果有
  $S\overset{*}\underset{rm}\Rightarrow\alpha A \omega\underset{rm}\alpha\beta\omega$,
  则紧跟
  $\alpha$
  的产生式
  $A\rightarrow \beta$
  是
  $\alpha\beta\omega$
  的一个句柄.
  为了方便起见,
  也会将产生式体 $\beta$ 称为一个句柄.

> 句柄右边的 $\omega$ 一定只包含终结符号.

如果文法无二义, 则句柄是唯一的.
(hint: 无二义性对应最右推导唯一性)

**活前缀**

#### 4.5.3 移入-归约语法分析技术

<!-- 趁我还记得, 先写一下: 貌似预测分析和移入归约的入栈方向是反着来的 -->

四种动作:

1. 移入 (shift)
2. 归约 (reduce)
3. 接受 (accept)
4. 报错 (error)

实现:
句柄的选择

句柄的性质:
句柄总是出现在栈的顶端, 绝不会出现在栈的中间

#### 4.5.4 移入-归约语法分析中的冲突

<!-- ! -->

## 4.6 LR 语法分析技术介绍: 简单 LR 技术

### 4.6.1 为什么使用 LR 语法分析器

### 4.6.2 项和 LR(0) 自动机

### 4.6.3 LR 语法分析算法

### 4.6.4 构造 SLR 语法分析表

### 4.6.5 可行前缀

<!-- !与 LL 分析的区别 -->

<!--
.6 二义文法的应用和自底向上分析的错误处理
.7 语法分析器生成工具


4.7 更强大的LR语法分析器	182
4.7.1 规范LR(1)项	182
4.7.2 构造LR(1)项集	183
4.7.3 规范LR(1)语法分析表	186
4.7.4 构造LALR语法分析表	187
4.7.5 高效构造LALR语法分析表的方法	190
4.7.6 LR语法分析表的压缩	193
4.7.7 4.7 节的练习	194
4.8 使用二义性文法	195
4.8.1 用优先级和结合性解决冲突	195
4.8.2  "悬空-else" 的二义性	196
4.8.3 LR语法分析中的错误恢复	198
4.8.4 4.8 节的练习	199
4.9 语法分析器生成工具	200
4.9.1 语法分析器生成工具Yacc	200
4.9.2 使用带有二义性文法的Yacc规约	202
4.9.3 用Lex创建Yacc的词法分析器	204
4.9.4 Yacc中的错误恢复	205
-->

## 参考资料

1.[LL and LR in Context: Why Parsing Tools Are Hard](https://blog.reverberate.org/2013/09/ll-and-lr-in-context-why-parsing-tools.html): 一篇 Google 工程师写的小短文, 有功夫了我想好好研究一下
